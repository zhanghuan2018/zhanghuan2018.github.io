<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="个人网站">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        前端优化 - zhanghuan2018的博客 | zhanghuan2018&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/js/viewer/viewer.min.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 坚持 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>zhanghuan2018</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2、开启GZip压缩"><span class="toc-text">2、开启GZip压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、服务器响应时间"><span class="toc-text">3、服务器响应时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、使用CDN"><span class="toc-text">4、使用CDN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、压缩CSS、JavaScript和HTML文件"><span class="toc-text">5、压缩CSS、JavaScript和HTML文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、避免重定向"><span class="toc-text">6、避免重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、指定字符集"><span class="toc-text">7、指定字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、避免错误请求"><span class="toc-text">8、避免错误请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14个最佳实践"><span class="toc-text">14个最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践1：使用DocumentFragments或innerHTML取代复杂的元素注入"><span class="toc-text">最佳实践1：使用DocumentFragments或innerHTML取代复杂的元素注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践2：高频执行事件-方法的防抖"><span class="toc-text">最佳实践2：高频执行事件/方法的防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践3：网络存储的静态缓存和非必要内容优化"><span class="toc-text">最佳实践3：网络存储的静态缓存和非必要内容优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践4：使用异步加载，延迟加载依赖"><span class="toc-text">最佳实践4：使用异步加载，延迟加载依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践5：使用Array-prototype-join代替字符串连接"><span class="toc-text">最佳实践5：使用Array.prototype.join代替字符串连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践6：尽可能使用CSS动画"><span class="toc-text">最佳实践6：尽可能使用CSS动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践7：使用事件委托"><span class="toc-text">最佳实践7：使用事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践8：使用Data-URI代替图片SRC"><span class="toc-text">最佳实践8：使用Data URI代替图片SRC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践9：使用媒体查询加载指定大小的背景图片"><span class="toc-text">最佳实践9：使用媒体查询加载指定大小的背景图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践10：使用索引对象"><span class="toc-text">最佳实践10：使用索引对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践11：控制DOM大小"><span class="toc-text">最佳实践11：控制DOM大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践12：在繁重的执行上使用Web-Workers"><span class="toc-text">最佳实践12：在繁重的执行上使用Web Workers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践13：链接CSS，避免使用-import"><span class="toc-text">最佳实践13：链接CSS，避免使用@import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践14：在CSS文件中包含多种介质类型"><span class="toc-text">最佳实践14：在CSS文件中包含多种介质类型</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 坚持 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        <div class="post-container">
    <div class="post-title">
        前端优化
    </div>

    <div class="post-meta">
        <span class="attr">
          发布于：<span>2019-05-11 15:11:30</span>
        </span>

        
          <span class="attr">标签：/
          
            <a class="tag" href="/tags/#前端" title="前端">前端</a>
            <span>/</span>
          
          </span>
        
        <span class="attr">
          访问：<span id="busuanzi_value_page_pv"></span>
        </span>
    </div>
    <div class="post-content ">
        <p>##1、图片优化<br>首先，你需要优化你网站上的图片，来获得丝毫加速网站的机会。从原图上移除额外的注解、不必要的空间和无用的颜色，将图片保存为JPEG格式，因为它即使占用空间小，也能保证图片的高质量。</p>
<p>对于WordPress网站，建议使用smush.it插件来自动优化网站的图片。如果图片是PNG格式，可以使用tinypng 优化图片，提高图片质量。</p>
<h2 id="2、开启GZip压缩"><a href="#2、开启GZip压缩" class="headerlink" title="2、开启GZip压缩"></a>2、开启GZip压缩</h2><p>GZip压缩听起来很复杂，但实际上很简单，被用于减少HTTP请求的大小来缩短响应时间。因为这允许你发送GZip压缩文件而不是HTML文件给浏览器，它将缩短页面等待时间和加载时间。对于Apache服务器，可以将下面的代码添加到.htaccess文件中来开启GZip压缩。</p>
<h2 id="3、服务器响应时间"><a href="#3、服务器响应时间" class="headerlink" title="3、服务器响应时间"></a>3、服务器响应时间</h2><p>即使网站已经格外优化，但是除非服务器响应时间非常快，否则就不会有什么大的效果。当涉及到提高网站的速度，服务器响应时间起着重要的作用。下面是一些提高服务器响应时间的建议。</p>
<p>有独立的服务器，而不是选择共享/托管服务器。</p>
<p>提高Web服务器的质量。</p>
<p>移除不必要的插件，只有那些必要的插件，才需要一直保持启用状态。</p>
<h2 id="4、使用CDN"><a href="#4、使用CDN" class="headerlink" title="4、使用CDN"></a>4、使用CDN</h2><p>内容分发网络(CDN)是位于不同地理位置的服务器组成的网络。每个服务器都拥有所有网站的文件副本。当用户请求文件和网页时，就可以直接从就近的网站服务器获取相应资源(也可以是从负载最小的服务器)。你可以使用Amazon cloud front 或者MaxCDN为网站开启CDN加速。</p>
<h2 id="5、压缩CSS、JavaScript和HTML文件"><a href="#5、压缩CSS、JavaScript和HTML文件" class="headerlink" title="5、压缩CSS、JavaScript和HTML文件"></a>5、压缩CSS、JavaScript和HTML文件</h2><p>通过删除所有不必要的空格和注释，从而减小文件大小，提高页面的加载速度。下面是一些优化CSS、JavaScript和HTML文件的流行工具，非常有用。</p>
<p>CSS Minifier</p>
<p>Avivo</p>
<p>HTML Compressor</p>
<h2 id="6、避免重定向"><a href="#6、避免重定向" class="headerlink" title="6、避免重定向"></a>6、避免重定向</h2><p>重定向是对网站访问者的一种极大的刺激。就类似你去一个朋友家，却发现你朋友早已经搬到三个街区远的地方了。重定向会消耗额外的时间，降低加载速度。</p>
<h2 id="7、指定字符集"><a href="#7、指定字符集" class="headerlink" title="7、指定字符集"></a>7、指定字符集</h2><p>指定字符集是加速浏览器渲染页面的另一个有用的技巧。下面的代码就能轻松实现：</p>
<h2 id="8、避免错误请求"><a href="#8、避免错误请求" class="headerlink" title="8、避免错误请求"></a>8、避免错误请求</h2><p>当用户在网站上搜索时，收到404或410错误是比较失望的。错误请求会对网站的页面加载速度产生不利影响。因此，建议你无论如何都要避免错误请求。Check My Link 能帮你找出404链接，清除它们，改善用户体验。</p>
<h2 id="14个最佳实践"><a href="#14个最佳实践" class="headerlink" title="14个最佳实践"></a>14个最佳实践</h2><h3 id="最佳实践1：使用DocumentFragments或innerHTML取代复杂的元素注入"><a href="#最佳实践1：使用DocumentFragments或innerHTML取代复杂的元素注入" class="headerlink" title="最佳实践1：使用DocumentFragments或innerHTML取代复杂的元素注入"></a>最佳实践1：使用DocumentFragments或innerHTML取代复杂的元素注入</h3><p>DOM操作在浏览器上是要付税的。尽管性能提升是在浏览器，DOM很慢，如果你没有注意到，你可能会察觉浏览器运行非常的慢。这就是为什么减少创建集中的DOM节点以及快速注入是那么的重要了。</p>
<p>现在假设我们页面中有一个</p>
<p>元素，调用AJAX获取JSON列表，然后使用JavaScript更新元素内容。通常，程序员会这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);  </span><br><span class="line">ajaxResult.items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 创建&lt;li&gt;元素  </span></span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);  </span><br><span class="line">    li.innerHTML = item.text;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;li&gt;元素常规操作，例如添加class，更改属性attribute，添加事件监听等  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迅速将&lt;li&gt;元素注入父级&lt;ul&gt;中  </span></span><br><span class="line">    list.apppendChild(li);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码其实是一个错误的写法，将</p>
<p>元素带着对每一个列表的DOM操作一起移植是非常慢的。如果你真的想要 使用document.createElement，并且将对象当做节点来处理，那么考虑到性能问题，你应该使用DocumentFragement。<br>DocumentFragement是一组子节点的“虚拟存储”，并且它没有父标签。在我们的例子中，将DocumentFragement想象成看不见的</p>
<p>元素，在 DOM外，一直保管着你的子节点，直到他们被注入DOM中。那么，原来的代码就可以用DocumentFragment优化一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();  </span><br><span class="line"></span><br><span class="line">ajaxResult.items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 创建&lt;li&gt;元素  </span></span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);  </span><br><span class="line">    li.innerHTML = item.text;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;li&gt;元素常规操作  </span></span><br><span class="line">    <span class="comment">// 例如添加class，更改属性attribute，添加事件监听，添加子节点等  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将&lt;li&gt;元素添加到碎片中  </span></span><br><span class="line">    frag.appendChild(li);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后将所有的列表对象通过DocumentFragment集中注入DOM  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).appendChild(frag);</span><br></pre></td></tr></table></figure></p>
<p>为DocumentFragment追加子元素，然后再将这个DocumentFragment加到父列表中，这一系列操作仅仅是一个DOM操作，因此它比起集中注入要快很多。</p>
<p>如果你不需要将列表对象当做节点来操作，更好的方法是用字符串构建HTML内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> htmlStr = <span class="string">''</span>;  </span><br><span class="line"></span><br><span class="line">ajaxResult.items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 构建包含HTML页面内容的字符串  </span></span><br><span class="line">    htmlStr += <span class="string">'&lt;li&gt;'</span> + item.text + <span class="string">'&lt;/li&gt;'</span>;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过innerHTML设定ul内容  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).innerHTML = htmlStr;</span><br></pre></td></tr></table></figure>
<p>这当中也只有一个DOM操作，并且比起DocumentFragment代码量更少。在任何情况下，这两种方法都比在每一次迭代中将元素注入DOM更高效。</p>
<h3 id="最佳实践2：高频执行事件-方法的防抖"><a href="#最佳实践2：高频执行事件-方法的防抖" class="headerlink" title="最佳实践2：高频执行事件/方法的防抖"></a>最佳实践2：高频执行事件/方法的防抖</h3><p>通常，开发人员会在有用户交互参与的地方添加事件，而往往这种事件会被频繁触发。想象一下窗口的resize事件或者是一个元素的onmouseover事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。</p>
<p>这就是为什么我们要引入防抖。</p>
<p>这里涉及到的知识点是高阶函数，感兴趣的朋友可以移步到我的另一篇博文全面理解Javascript的面向对象(一)，里面的函数节流部分就是实现高频执行事件/方法的防抖。</p>
<p>防抖可以限制一个方法在一定时间内执行的次数。以下代码是个防抖示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> timeout;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;  </span><br><span class="line">        <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">            timeout = <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">if</span> (!immediate) func.apply(context, args);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;  </span><br><span class="line">        clearTimeout(timeout);  </span><br><span class="line">        timeout = setTimeout(later, wait);  </span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args);  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">添加resize的回调函数，但是只允许它每<span class="number">300</span>毫秒执行一次</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里写resize过程  </span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">300</span>));</span><br></pre></td></tr></table></figure>
<p>debounce方法返回一个方法，用来包住你的回调函数，限制他的执行频率。使用这个防抖方法，就可以让你写的频繁回调的方法不会妨碍用户的浏览器！</p>
<h3 id="最佳实践3：网络存储的静态缓存和非必要内容优化"><a href="#最佳实践3：网络存储的静态缓存和非必要内容优化" class="headerlink" title="最佳实践3：网络存储的静态缓存和非必要内容优化"></a>最佳实践3：网络存储的静态缓存和非必要内容优化</h3><p>Web Storage的API曾经是Cookie API一个显著的进步，并且为开发者使用了很多年了。这个API是合理的，更大存储量的，而且是更为健全理智的。一种策略是去使用Session存储来存 储非必要的，更为静态的内容，例如侧边栏的HTML内容，从Ajax加载进来的文章内容，或者一些其他的各种各样的片断，是我们只想请求一次的。</p>
<p>我们可以使用JavaScript编写一段代码，利用Web Storage使这些内容加载更加简单:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cacheObj = <span class="built_in">window</span>.sessionStorage || &#123;  </span><br><span class="line">        getItem: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[key];  </span><br><span class="line">        &#125;,  </span><br><span class="line">        setItem: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>[key] = value;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.isFresh(key);  </span><br><span class="line">        &#125;,  </span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">key, value, minutes</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">var</span> expDate = <span class="keyword">new</span> <span class="built_in">Date</span>();  </span><br><span class="line">            expDate.setMinutes(expDate.getMinutes() + (minutes || <span class="number">0</span>));  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                cacheObj.setItem(key, <span class="built_in">JSON</span>.stringify(&#123;  </span><br><span class="line">                    value: value,  </span><br><span class="line">                    expires: expDate.getTime()  </span><br><span class="line">                &#125;));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span>(e) &#123; &#125;  </span><br><span class="line">        &#125;,  </span><br><span class="line">        isFresh: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;  </span><br><span class="line">            <span class="comment">// 返回值或者返回false  </span></span><br><span class="line">            <span class="keyword">var</span> item;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                item = <span class="built_in">JSON</span>.parse(cacheObj.getItem(key));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span>(e) &#123;&#125;  </span><br><span class="line">            <span class="keyword">if</span>(!item) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 日期算法  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() &gt; item.expires ? <span class="literal">false</span> : item.value;  </span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个工具提供了一个基础的get和set方法，同isFresh方法一样，保证了存储的数据不会过期。调用方法也非常简单:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'storage'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">storage</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> content = storage.get(<span class="string">'sidebarContent'</span>);  </span><br><span class="line">    <span class="keyword">if</span>(!content) &#123;  </span><br><span class="line">        <span class="comment">// Do an AJAX request to get the sidebar content  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... and then store returned content for an hour  </span></span><br><span class="line">        storage.set(<span class="string">'sidebarContent'</span>, content, <span class="number">60</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在同样的内容不会被重复请求，你的应用运行的更加有效。花一点儿时间，看看你的网站设计，将那些不会变化，但是会被不断请求的内容挑出来，你可以使用Web Storage工具来提升你网站的性能。</p>
<h3 id="最佳实践4：使用异步加载，延迟加载依赖"><a href="#最佳实践4：使用异步加载，延迟加载依赖" class="headerlink" title="最佳实践4：使用异步加载，延迟加载依赖"></a>最佳实践4：使用异步加载，延迟加载依赖</h3><p>RequireJS已经迎来了异步加载和AMD格式的巨大浪潮。XMLHttpRequest(该对象可以调用AJAX)使得资源的异步加载变得流行起来，它允许无阻塞资源加载，并且使 onload 启动更快，允许页面内容加载，而不需要刷新页面。</p>
<p>我所用的异步加载器是John Hann的curl。curl加载器是基本的异步加载器，可以被配置，拥有很好的插件。以下是一小段curl的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 基本使用:  加载一部分AMD格式的模块  </span></span><br><span class="line">curl([<span class="string">'social'</span>, <span class="string">'dom'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">social, dom</span>) </span>&#123;  </span><br><span class="line">    dom.setElementContent(<span class="string">'.social-container'</span>, social.loadWidgets());  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个使用Google Analytics的模块，该模块是非AMD格式的  </span></span><br><span class="line">define([<span class="string">"js!//google-analytics.com/ga.js"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// Return a simple custom Google Analytics controller  </span></span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">        trackPageView: <span class="function"><span class="keyword">function</span>(<span class="params">href</span>) </span>&#123;  </span><br><span class="line">            _gaq.push([<span class="string">"_trackPageview"</span>, url]);  </span><br><span class="line">        &#125;,  </span><br><span class="line">        trackEvent: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, href</span>) </span>&#123;  </span><br><span class="line">            _gaq.push([<span class="string">"_trackEvent"</span>, <span class="string">"Interactions"</span>, eventName, <span class="string">""</span>, href || <span class="built_in">window</span>.location, <span class="literal">true</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载一个不带回调方法的非AMD的js文件  </span></span><br><span class="line">curl([<span class="string">'js!//somesite.com/widgets.js'</span>]);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JavaScript和CSS文件作为模块加载  </span></span><br><span class="line">curl([<span class="string">'js!libs/prism/prism.js'</span>, <span class="string">'css!libs/prism/prism.css'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    Prism.highlightAll();  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载一个AJAX请求的URL  </span></span><br><span class="line">curl([<span class="string">'text!sidebar.php'</span>, <span class="string">'storage'</span>, <span class="string">'dom'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">content, storage, dom</span>) </span>&#123;  </span><br><span class="line">    storage.set(<span class="string">'sidebar'</span>, content, <span class="number">60</span>);  </span><br><span class="line">    dom.setElementContent(<span class="string">'.sidebar'</span>, content);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可能早就了解，异步加载可以大大提高万展速度，但是我想在此说明的是，你要使用异步加载！使用了之后你可以看到区别，更重要的是，你的用户可以看到区别。</p>
<p>当你可以根据页面内容延迟加载依赖的时候，你就可以体会到异步加载的好处了。例如，你可以只加载Twitter，Facebook和Google Plus到应用了名为social的CSS样式的div元素中。“在加载前检查是否需要”策略可以为我的用户节省好几KB的莫须有的加载。</p>
<h3 id="最佳实践5：使用Array-prototype-join代替字符串连接"><a href="#最佳实践5：使用Array-prototype-join代替字符串连接" class="headerlink" title="最佳实践5：使用Array.prototype.join代替字符串连接"></a>最佳实践5：使用Array.prototype.join代替字符串连接</h3><p>有一种非常简单的客户端优化方式，就是用Array.prototype.join代替原有的基本的字符连接的写法。在上面的“最佳实践1”中，我在代码中使用了基本字符连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">htmlStr += <span class="string">'&lt;li&gt;'</span> + item.text + <span class="string">'&lt;/li&gt;'</span>;</span><br></pre></td></tr></table></figure>
<p>但是下面这段代码中，我用了优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = [];  </span><br><span class="line"></span><br><span class="line">ajaxResult.items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 构建字符串  </span></span><br><span class="line">    items.push(<span class="string">'&lt;li&gt;'</span>, item.text, <span class="string">'&lt;/li&gt;'</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过innerHTML设置列表内容  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).innerHTML = items.join(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>
<p>也许你需要花上一点儿时间来看看这个数组是做什么用的，但是所有的用户都从这个优化中受益匪浅。</p>
<h3 id="最佳实践6：尽可能使用CSS动画"><a href="#最佳实践6：尽可能使用CSS动画" class="headerlink" title="最佳实践6：尽可能使用CSS动画"></a>最佳实践6：尽可能使用CSS动画</h3><p>网站设计对美观特性和可配置元素动画的大量需求，使得一些JavaScript类库，如jQuery，MooTools大量的被使用。尽管现在浏览器支持CSS的transformation和keyframe所做的动画，现在仍有很多人使用JavaScript制作动画效果，但是实际上使用CSS动画比起JavaScript驱动的动画效率更高。CSS动画同时需要更少的代码。很多的CSS动画是用GPU处理的，因此动画本身很流畅，当然你可以使用下面这个简单的CSS强制使你的硬件加速：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.myAnimation &#123;  </span><br><span class="line">    animation: someAnimation <span class="number">1</span>s;  </span><br><span class="line">    transform: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 强制硬件加速 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tansform:transform(0,0,0)在不会影响其他动画的同时将通话送入硬件加速。在不支持CSS动画的情况下（IE8及以下版本的浏览器），你可以引入JavaScript动画逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--[<span class="keyword">if</span> 低于IE8版本]&gt;  </span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-1.9.1.min.js"</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script src=<span class="string">"/js/ie-animations.js"</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<p>在上例中，ie-animations.js文件必须包含你自定义的jQuery代码，用于当CSS动画在早期IE中不被支持的情况下，来替代CSS动画完成动画效果。完美的通过CSS动画来优化动画，通过JavaScript来支持全局动画效果。</p>
<h3 id="最佳实践7：使用事件委托"><a href="#最佳实践7：使用事件委托" class="headerlink" title="最佳实践7：使用事件委托"></a>最佳实践7：使用事件委托</h3><p>想象一下，如果你有一个无序列表，里面有一堆</p>
<p>元素，每一个<br>元素都会在点击的时候触发一个行为。这个时候，你通常会在每一个元素上添加一个事件监听，但是如果当这个元素或者你添加了监听的这个对象会被频繁的移除添加呢？这个时候，你在移除添加元素的同时需要处理事件监听的移除和添加。这个时候，我们就需要引入事件委托了。<br>事件委托是在父级元素上添加一个事件监听，来替代在每一个子元素上添加事件监听。当事件被触发时，event.target会评估相应的措施是否需要被执行。下面我们给出了一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取元素，添加事件监听  </span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            　　<span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">            　　oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">                　　　　<span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">                　　　　<span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">                　　　　<span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">        　　　　　　　        alert(target.innerHTML);</span><br><span class="line">                　　　　&#125;</span><br><span class="line">            　　&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子是不可思议的简单，当事件发生的时候，它没有轮询父节点去寻找匹配的元素或选择器，且它不支持基于选择器的查询（例如用class name，或者id来查询）。所有的JavaScript框架提供了委托选择器匹配。重点是，你避免了为每一个元素加载事件监听，而是在父元素上加一个事件监听。这样大大的增加了效率，并且减少了很多维护！</p>
<h3 id="最佳实践8：使用Data-URI代替图片SRC"><a href="#最佳实践8：使用Data-URI代替图片SRC" class="headerlink" title="最佳实践8：使用Data URI代替图片SRC"></a>最佳实践8：使用Data URI代替图片SRC</h3><p>提升页面大小的效率，不仅仅是取决于使用精灵或是压缩代码，给定页面的请求数量在前端性能中也占有了很不小的重量。减少请求可以让你的网站加载更快，而其中一种减少页面请求的方法就是用Data URI代替图片的src属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 以前的写法 --&gt;  </span><br><span class="line">&lt;img src=<span class="string">"/images/logo.png"</span> /&gt;  </span><br><span class="line"></span><br><span class="line">&lt;!-- 使用data URI的写法 --&gt;  </span><br><span class="line">&lt;img src=<span class="string">"data: image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAPAAA/+4ADkFkb2JlAGTAAAAAAf/bAIQABgQEBAUEBgUFBgkGBQYJCwgGBggLDAoKCwoKDBAMDAwMDAwQDA4PEA8ODBMTFBQTExwbGxscHx8fHx8fHx8fHwEHBwcNDA0YEBAYGhURFRofHx8fHx8fHx8fHx8fHx8fH ...."</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>范例:  <a href="http://davidwalsh.name/demo/data-uri-php.php" target="_blank" rel="noopener">http://davidwalsh.name/demo/data-uri-php.php</a></p>
<p>当然页面大小会增加（如果你的服务器使用适当的gzip内容，这个增加会很小），但是你减少了潜在的请求，同时也在过程中减少了服务器请求的数量。现在大多数浏览器都支持Data URI，在CSS中的背景骨片也可以使用Data URI，因此这个策略现在已经可以在应用层级，广泛应用。</p>
<h3 id="最佳实践9：使用媒体查询加载指定大小的背景图片"><a href="#最佳实践9：使用媒体查询加载指定大小的背景图片" class="headerlink" title="最佳实践9：使用媒体查询加载指定大小的背景图片"></a>最佳实践9：使用媒体查询加载指定大小的背景图片</h3><p>直到CSS @supports被广泛支持，CSS媒体查询的使用接近于CSS中写逻辑控制。我们经常用CSS媒体查询来根据设备调整CSS属性（通常根据屏幕宽度调整CSS属性），例如根据不同的屏幕宽度来设置不同的元素宽度或者是悬浮位置。那么我们为什么不用这种方式来改变背景图片呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 默认是为桌面应用加载图片 */</span>  </span><br><span class="line">.someElement &#123; background-image: url(sunset.jpg); &#125;  </span><br><span class="line"></span><br><span class="line">@media only screen and (max-width : <span class="number">1024</span>px) &#123;  </span><br><span class="line">    .someElement &#123; background-image: url(sunset-small.jpg); &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码片段是为手机设备或是类似的移动设备加载一个较小尺寸的图片，特别是需要一个特别小的图片时（例如图片的大小几乎不可视）。</p>
<h3 id="最佳实践10：使用索引对象"><a href="#最佳实践10：使用索引对象" class="headerlink" title="最佳实践10：使用索引对象"></a>最佳实践10：使用索引对象</h3><p>这一篇，我们将讲讲使用索引对象检索代替遍历数组，提高遍历速度。</p>
<p>AJAX和JSON一个最常见的使用案例是接收包含一组对象的数组，然后从这组数组中根据给定的值搜索对象。让我们看一个简单的例子，下面这个例子中，你从用户接收一个数组，然后你可以根据username的值来搜索用户对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">desiredUsername</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> searchResult = ajaxResult.users.filter(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> user.username == desiredUsername;  </span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> searchResult.length ? searchResult[<span class="number">0</span>] : <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户名获取用户  </span></span><br><span class="line"><span class="keyword">var</span> davidwalsh = getUser(<span class="string">"davidwalsh"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户名获取另一个用户.  </span></span><br><span class="line"><span class="keyword">var</span> techpro = getuser(<span class="string">"tech-pro"</span>);</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以运行，但是并不是很有效，当我们想要获取一个用户时，我们就要遍历一次数组。那么更好的方法是创建一个新的对象，对每一个唯一的值建立一个索引，在上面这个例子中，用username作为索引，这个数组对象可以写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> userStore = &#123;&#125;;  </span><br><span class="line">ajaxResult.users.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;  </span><br><span class="line">    userStore[user.username] = user;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在当你想要找一个用户对象时，我们可以直接通过索引找到这个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> davidwalsh = userStore.davidwalsh;  </span><br><span class="line"><span class="keyword">var</span> techpro = userStore[<span class="string">"tech-pro"</span>];</span><br></pre></td></tr></table></figure>
<p>这样的代码写起来更好一些，也很简便，通过索引搜索比起遍历整个数组更加快捷。</p>
<h3 id="最佳实践11：控制DOM大小"><a href="#最佳实践11：控制DOM大小" class="headerlink" title="最佳实践11：控制DOM大小"></a>最佳实践11：控制DOM大小</h3><p>这一篇中，我们要说如何控制DOM的大小，来优化前端性能。</p>
<p>DOM很慢是众所周知的，使得网站变慢的罪魁祸首是大量的DOM。想象一下，假如你有一个有着上千节点的DOM，在想象一下，使用querySelectorAll或者getElementByTagName，或者是其他以DOM为中心的搜索方式来搜索一个节点，即使是使用内置方法，这也将是一个非常费力的过程。你要知道，多余的DOM节点会使其他的实用程序也变慢的。</p>
<p>我见过的一种情况，DOM的大小悄然增加，是在一个AJAX网站，它将所有的页面都存在了DOM中，当一个新的页面通过AJAX被加载时，旧的页面就会被存入隐藏的DOM节点。对于DOM的速度，将有灾难性的降低，特别是当一个页面是动态加载的。所以你需要一种更好的方法。</p>
<p>在这种情况下，当页面是通过AJAX加载的，并且以前的页面是存储在客户端的，最好的方法就是将内容通过String HTML存储（将内容从DOM中移除），然后使用事件委托来避免特定元素事件。这么做的同时，当在客户端缓存内容的时候，可以避免大量的DOM生成。</p>
<p>通常控制DOM大小的技巧包括：</p>
<p>使用:before和:after伪元素<br>延迟加载和呈现内容<br>使用事件委托，更简便的将节点转换成字符串存储<br>简单一句话：尽量使你的DOM越小越好。</p>
<h3 id="最佳实践12：在繁重的执行上使用Web-Workers"><a href="#最佳实践12：在繁重的执行上使用Web-Workers" class="headerlink" title="最佳实践12：在繁重的执行上使用Web Workers"></a>最佳实践12：在繁重的执行上使用Web Workers</h3><p>这一篇我们将介绍Web Workder，一种可以将繁重操作移到独立进程的方法。</p>
<p>Web Workders在前段时间被引入流行的浏览器中，但是好像并没有被广泛应用。Web Workers的主要功能是在一般浏览器执行范围外执行繁重的方法。它不会访问DOM，所以你必须传入方法涉及的节点。</p>
<p>以下是一段Web Workder的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用Web Worker */</span>  </span><br><span class="line"><span class="comment">//  启动worker  </span></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">"/path/to/web/worker/resource.js"</span>);  </span><br><span class="line">worker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 我们从web worker获取信息!  </span></span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指导Web Worker工作！  </span></span><br><span class="line">worker.postMessage(&#123; <span class="attr">cmd</span>: <span class="string">"processImageData"</span>, <span class="attr">data</span>: convertImageToDataUri(myImage) &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  resource.js就是一个Web workder   </span></span><br><span class="line">self.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> data = event.data;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (data.cmd) &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'process'</span>:<span class="keyword">return</span> processImageData(data.imageData); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processImageData</span>(<span class="params">imageData</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 对图像进行操作  </span></span><br><span class="line">    <span class="comment">// 例如将它改成灰度  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newImageData;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码是一个教你如何使用Web Worker在其他进程中做一些繁重工作的简单示例。它要执行的是将一个图片从普通颜色转个灰度，因为这是一个比较繁重的过程，所以你可以将这个进程提交给Web Worker，使你的浏览器负载不是很大。Data通过message事件传回。</p>
<p>你可以仔细阅读以下MDN上关于Web Workder的使用，也许在你的网站上有一些功能可以移到其他的独立进程中去执行。</p>
<h3 id="最佳实践13：链接CSS，避免使用-import"><a href="#最佳实践13：链接CSS，避免使用-import" class="headerlink" title="最佳实践13：链接CSS，避免使用@import"></a>最佳实践13：链接CSS，避免使用@import</h3><p>有时候，@import太好用以至于很难抗拒它的诱惑，但是为了减少令人抓狂的请求，你必须要拒绝它！最常见的用法是在一个”main”CSS文件中，没有任何的内容，只有@import规则。有时，多个@import规则往往会造成事件嵌套：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 主CSS文件(main.css)  </span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"reset.css"</span>;  </span><br><span class="line">@<span class="keyword">import</span> <span class="string">"structure.css"</span>;  </span><br><span class="line">@<span class="keyword">import</span> <span class="string">"tutorials.css"</span>;  </span><br><span class="line">@<span class="keyword">import</span> <span class="string">"contact.css"</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在tutorials.css文件中，会继续有@import  </span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"document.css"</span>;  </span><br><span class="line">@<span class="keyword">import</span> <span class="string">"syntax-highlighter.css"</span>;</span><br></pre></td></tr></table></figure>
<p>我们这样写CSS文件，在文件中多了两个多余链接，因此会使页面加载变慢。SASS可以读取@import语句，链接CSS内容到一个文件中，减少了多余的请求，控制了CSS文件的大小。</p>
<h3 id="最佳实践14：在CSS文件中包含多种介质类型"><a href="#最佳实践14：在CSS文件中包含多种介质类型" class="headerlink" title="最佳实践14：在CSS文件中包含多种介质类型"></a>最佳实践14：在CSS文件中包含多种介质类型</h3><p>在上面第13个最佳实践中我们说过，多个CSS文件可以通过@import规则合并到一起。但是很多程序员不知道的是，多种CSS介质类型也可以合并到一个文件中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 以下全部写在一个CSS文件中 */</span>  </span><br><span class="line"></span><br><span class="line">@media screen &#123;  </span><br><span class="line">    <span class="comment">/* 所有默认的结构设计和元素样式写在这里 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@media print &#123;  </span><br><span class="line">    <span class="comment">/* 调整打印时的样式 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@media only screen and (max-width : <span class="number">1024</span>px) &#123;  </span><br><span class="line">    <span class="comment">/* 使用ipad或者移动电话时的样式设定 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于文件的大小，什么时候必须合并介质，或是什么时候必须分开设定，CSS并没有硬性规定，但是我会比较建议将所有的介质合并，除非其中一个介质所占的比例比起其他大了许多。少一个请求对于客户端和服务器都将轻松不少，而且在大多数情况下，附赠的介质类型相比主屏介质类型要相对小很多。</p>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank" href="https://github.com/zhanghuan2018">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://zhanghuan2018.github.io/">zhanghuan2018</a></span>
        <span>/</span>
        
        <span><a href="/html">html-demo</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        © 2018 | Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>


</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/viewer/viewer.min.js"></script>
<script src="/js/layer/layer.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
